use crate::lex;
use lex::wrap::Wrap;
use crate::value;
use std::result::Result;
use crate::parser::ParseError;

grammar<'source>;

extern {
  type Location = usize;
  type Error = lex::wrap::Error;
  enum Wrap<'source> {
    "true"  => Wrap::Token{tok: lex::Token::True, string: <&'source str>},
    "false" => Wrap::Token{tok: lex::Token::False, string: <&'source str>},
    "null"  => Wrap::Token{tok: lex::Token::Null, string: <&'source str>},
    ","	    => Wrap::Token{tok: lex::Token::Comma, string: <&'source str>},
    ":"	    => Wrap::Token{tok: lex::Token::Colon, string: <&'source str>},
    "{"	    => Wrap::Token{tok: lex::Token::LBrace, string: <&'source str>},
    "}"	    => Wrap::Token{tok: lex::Token::RBrace, string: <&'source str>},
    "["	    => Wrap::Token{tok: lex::Token::LBrack, string: <&'source str>},
    "]"	    => Wrap::Token{tok: lex::Token::RBrack, string: <&'source str>},
    "\""  => Wrap::Token{tok: lex::Token::Quote, string: <&'source str>},
    string => Wrap::Token{tok: lex::Token::String, string: <&'source str>},
    number  => Wrap::Token{tok: lex::Token::Number, string: <&'source str>},
  }
}

pub json = value;

quoted_string: &'source str = {
   // So we've got an empty string,
   // We need to return a string of the appropriate lifetime.
   <umm: "\""> "\"" => &umm[umm.len()..],
   "\"" <s: string> "\"" => s,
}

value: value::Value<'source> = {
   "true"      =>? Ok(value::Value::<'source>::Bool(true)),
   "false"     =>? Ok(value::Value::<'source>::Bool(false)),
   "null"      =>? Ok(value::Value::<'source>::Null),
   <a: array>  =>? Ok(value::Value::<'source>::Array(a)),
   <o: objects> =>? Ok(value::Value::<'source>::Object(o)),
   <l:@L> <n: number> <r:@R> =>? {
	let result = lexical::parse(n.as_bytes());
	match result {
	   Ok(n) => Ok(value::Value::Number(n)),
	   Err(_e) => Err(ParseError::User{
		error: lex::wrap::Error::NumericalError{range:l..r},
	   })
	}
   },
   quoted_string =>? Ok(value::Value::<'source>::String(<>)),
};

// No trailing comma.
CommaSep<T>: Vec<T> = {
  <es: CommaSep<T>> "," <e: T> => {let mut es = es; es.push(e); es },
  <e: T> => vec![e],
}

object: (&'source str, value::Value<'source>) = {
  <s:quoted_string> ":" <v:value> => (s,v),
}

objects: Vec<(&'source str, value::Value<'source>)> = {
  "{" <es: CommaSep<object>> "}" => es,
  "{" "}" => vec![],
}

array: Vec<value::Value<'source>> = {
  "[" <a: CommaSep<value>> "]" => a,
  "[" "]" => vec![],
}
